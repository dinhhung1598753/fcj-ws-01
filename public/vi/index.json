[
{
	"uri": "//localhost:1313/vi/",
	"title": "Xây Dựng Ứng Dụng Serverless",
	"tags": [],
	"description": "",
	"content": "Xây Dựng Ứng Dụng Serverless Tổng Quan Trong workshop này, tôi sẽ giới thiệu về Serverless Framework và cách sử dụng nó để xây dựng một ứng dụng serverless và tích hợp với một số dịch vụ AWS.\nKhởi tạo hạ tầng cho frontend: Bạn sẽ sử dụng Serverless Framework để thiết lập hạ tầng cần thiết để triển khai một ứng dụng web tĩnh được lưu trữ trên S3. Khởi tạo hạ tầng cho backend và triển khai các hàm Lambda: Sử dụng Serverless Framework, bạn sẽ triển khai các hàm Lambda cho backend và cấu hình API Gateway, DynamoDB, và các dịch vụ AWS khác. Tạo một pipeline CI/CD: Thiết lập một CodePipeline tự động để xây dựng và triển khai ứng dụng frontend lên AWS S3 mỗi khi có cập nhật trong kho mã nguồn. Nội Dung Giới thiệu Danh sách nhiệm vụ Kết luận Dọn dẹp tài nguyên "
},
{
	"uri": "//localhost:1313/vi/2-tasklist/2.1-createiamforserverless/",
	"title": "Chuẩn Bị Người dùng IAM cho Serverless",
	"tags": [],
	"description": "",
	"content": "Chuẩn Bị IAM user cho Serverless Trong bước này, chúng ta sẽ tạo một IAM user và tạo các secret access key để Serverless Framework có thể tương tác với các tài nguyên AWS.\nCác bước thực hiện: Đăng nhập vào AWS Management Console\nTruy cập AWS Management Console và đăng nhập bằng thông tin xác thực của bạn.\nĐi đến Bảng điều khiển IAM\nTrong AWS Management Console, tìm kiếm \u0026ldquo;IAM\u0026rdquo; trong thanh tìm kiếm và mở Bảng điều khiển IAM.\nNhấp vào Users\nTừ menu bên trái, chọn Users. Tại đây, bạn sẽ quản lý tất cả các Users trong tài khoản AWS của bạn.\nTạo User\nNhấp vào nút Create User. Nhập User name (ví dụ: serverless-deployer). Chọn Access type là \u0026ldquo;Programmatic access\u0026rdquo; để tạo Access key và Secret access key mà Serverless Framework sẽ sử dụng. Attach Policies Directly\nTrong phần \u0026ldquo;Set permissions\u0026rdquo;, chọn Attach Policies Directly. Để kiểm soát chi tiết hơn, chúng ta sẽ tạo một chính sách tùy chỉnh trong bước tiếp theo. Tạo Chính sách\nTrong phần \u0026ldquo;Attach policies\u0026rdquo;, nhấp vào Create policy. Chọn JSON trong Trình chỉnh sửa Policy\nTrong trình hướng dẫn tạo chính sách, chuyển sang tab JSON trong trình chỉnh sửa chính sách. Thêm Policy Permissions\nSao chép và dán đoạn JSON sau vào trình chỉnh sửa, điều này cấp quyền cần thiết để quản lý các tài nguyên. Bạn có thể tùy chỉnh chính sách này dựa trên các dịch vụ bạn sẽ sử dụng.\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;Statement1\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;cloudformation:*\u0026#34;, \u0026#34;lambda:*\u0026#34;, \u0026#34;s3:*\u0026#34;, \u0026#34;logs:*\u0026#34;, \u0026#34;dynamodb:*\u0026#34;, \u0026#34;events:*\u0026#34;, \u0026#34;apigateway:*\u0026#34;, \u0026#34;iam:GetRole\u0026#34;, \u0026#34;iam:CreateRole\u0026#34;, \u0026#34;iam:*\u0026#34;, \u0026#34;cognito-idp:*\u0026#34;, \u0026#34;cloudfront:*\u0026#34; ], \u0026#34;Resource \u0026#34;: \u0026#34;*\u0026#34; } ] } Xem lại và Tạo Policy\nNhấp vào Next: Review. Cung cấp một Tên cho chính sách của bạn (ví dụ: ServerlessDeploymentPolicy) và xem lại các quyền. Nhấp vào Create policy để hoàn tất. Attach the New Policy\nSau khi tạo chính sách, quay lại màn hình tạo người dùng. Trong phần \u0026ldquo;Attach the New Policy\u0026rdquo;, tìm kiếm chính sách mà bạn vừa tạo (ví dụ: ServerlessDeploymentPolicy). Chọn chính sách từ danh sách và nhấp vào Nexto. Hoàn Tất Tạo User Xem lại các chi tiết và quyền đã gán cho IAM user. Nhấp vào Create User để hoàn tất việc tạo người dùng. Tải Về Các Khóa Truy Cập Sau khi tạo thành công người dùng IAM, bạn cần tạo và tải về các khóa truy cập:\nNhấp vào IAM User\nTrong bảng điều khiển IAM, nhấp vào người dùng bạn vừa tạo từ danh sách người dùng.\nChuyển đến Tab Security Credentials\nĐi đến tab Thông tin bảo mật.\nTạo Khóa Truy Cập\nCuộn xuống phần Access keysp. Nhấp vào nút Create access key. Chọn Application Type\nTrong wizard \u0026ldquo;Tạo khóa truy cập\u0026rdquo;, chọn Application running outside AWS. Nhấp vào Next để tiếp tục. Tải Về Access Key\nKhi khóa truy cập được tạo, bạn sẽ thấy Access key ID và Secret access key. Download thông tin đăng nhập bằng cách nhấp vào nút Download .csv, hoặc sao chép thủ công Access key ID và Secret access key. Quan trọng: Đảm bảo lưu trữ các thông tin đăng nhập này một cách an toàn vì bạn sẽ cần chúng để cấu hình Serverless Framework. Secret access key chỉ hiển thị một lần, vì vậy hãy chắc chắn lưu nó ngay lập tức.\nBạn sẽ sử dụng các thông tin đăng nhập này trong các bước tiếp theo để cấu hình Serverless Framework.\nCấu Hình Serverless Framework với Thông Tin Đăng Nhập IAM Với phiên bản Serverless Framework 4, bạn không cần cấu hình thông tin đăng nhập qua dòng lệnh nữa. Thay vào đó, bạn có thể thêm chúng trực tiếp vào tệp .env của dự án:\nMở Thư Mục Dự Án của Bạn\nĐiều hướng đến thư mục gốc của dự án Serverless của bạn.\nTạo hoặc Chỉnh Sửa Tệp .env\nNếu bạn chưa có tệp .env, hãy tạo một tệp mới trong thư mục gốc của dự án. Nếu tệp đã tồn tại, mở nó để chỉnh sửa.\nThêm Thông Tin Đăng Nhập của Bạn\nThêm các dòng sau vào tệp .env, thay thế \u0026lt;Your_Access_Key_ID\u0026gt; và \u0026lt;Your_Secret_Access_Key\u0026gt; bằng giá trị thực tế:\nAWS_ACCESS_KEY_ID=\u0026lt;Your_Access_Key_ID\u0026gt; AWS_SECRET_ACCESS_KEY=\u0026lt;Your_Secret_Access_Key\u0026gt; Lưu Tệp .env\nĐảm bảo rằng tệp được lưu với thông tin đăng nhập chính xác.\nServerless Framework sẽ tự động sử dụng các thông tin đăng nhập này cho việc triển khai và các hoạt động khác.\n"
},
{
	"uri": "//localhost:1313/vi/1-introduce/",
	"title": "Tổng Quan Workshop",
	"tags": [],
	"description": "",
	"content": "Mục Tiêu: Sau workshop này, bạn sẽ có khả năng:\nTạo hạ tầng sử dụng Serverless Framework Triển khai các hàm Lambda Tạo một pipeline CI/CD sử dụng CodePipeline, CodeBuild, và CodeDeploy Sources: FE: [fcj-ws-fe](https://github.com/dinhhung1598753/fcj-ws-fe)\rBE: [fcj-ws-api](https://github.com/dinhhung1598753/fcj-ws-api)\rThời Gian: Workshop này sẽ mất 2 giờ để hoàn thành.\nKiến Trúc: "
},
{
	"uri": "//localhost:1313/vi/2-tasklist/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "\rBạn cần tạo sẵn 1 Linux instance thuộc public subnet và 1 Window instance thuộc private subnet để thực hiện bài thực hành này.\nĐể tìm hiểu cách tạo các EC2 instance và VPC với public/private subnet các bạn có thể tham khảo bài lab :\nGiới thiệu về Amazon EC2 Làm việc với Amazon VPC Để sử dụng System Manager để quản lý window instance nói riêng và các instance nói chung của chúng ta trên AWS, ta cần phải cung cấp quyền cho các instance của chúng ta có thể làm việc với System Manager.Trong phần chuẩn bị này, chúng ta cũng sẽ tiến hành tạo IAM Role để cấp quyền cho các instance có thể làm việc với System Manager.\nNội dung Chuẩn bị VPC và EC2 Instance Tạo IAM Role "
},
{
	"uri": "//localhost:1313/vi/2-tasklist/2.2-createfeinfrastructure/",
	"title": "Tạo Website Tĩnh S3 và CloudFront",
	"tags": [],
	"description": "",
	"content": "Giới Thiệu Trong bước này, chúng ta sẽ thiết lập một bucket S3 để lưu trữ một website tĩnh và cấu hình một phân phối CloudFront để phục vụ nội dung qua CDN.\nCác Bước Thực Hiện Kéo Mã Nguồn Frontend\nNguồn: fcj-ws-fe\nCài Đặt Serverless Framework và Các Phụ Thuộc\nnpm i -g serverless@4.2.5 Tạo tài nguyên: S3 Bucket và CloudFront\nTạo Service name và AWS region\nHãy thay thế tên dịch vụ bằng tên bạn muốn\nservice: fcj-ws-fe # Your service name provider: name: aws region: ap-southeast-1 # aws region stage: dev Tạo S3 Bucket và Configuration\nThêm cấu hình sau vào tệp serverless.yml của bạn để tạo một S3 bucket và cấu hình nó cho việc lưu trữ website tĩnh:\n# Define the S3 bucket resource S3Bucket: Type: AWS::S3::Bucket Properties: # The bucket name in this example is \u0026#34;fcj-ws-fe-dev\u0026#34;, you need to change Bucket name or service name to make Bucket name is unique BucketName: ${self:service}-${self:provider.stage} WebsiteConfiguration: # Configure the bucket to serve a static website IndexDocument: index.html # Default page to serve ErrorDocument: index.html # Error page to serve (useful for single-page apps) PublicAccessBlockConfiguration: # Disable public access block for bucket policy BlockPublicAcls: true IgnorePublicAcls: true BlockPublicPolicy: false RestrictPublicBuckets: false Đặt Chính Sách S3 Bucket Để Cho Phép Truy Cập Đọc Công Khai\nThêm cấu hình sau để cho phép truy cập đọc công khai vào S3 bucket:\n# Set the bucket policy to allow public read access S3BucketPolicy: Type: AWS::S3::BucketPolicy Properties: Bucket: !Ref S3Bucket PolicyDocument: Version: \u0026#34;2012-10-17\u0026#34; Statement: - Sid: PublicReadGetObject Effect: Allow Principal: \u0026#34;*\u0026#34; Action: \u0026#34;s3:GetObject\u0026#34; Resource: !Sub \u0026#34;${S3Bucket.Arn}/*\u0026#34; Tạo CloudFront Distribution\nThêm cấu hình sau để tạo một CloudFront distribution:\n# Define the CloudFront distribution resource CloudFrontDistribution: Type: AWS::CloudFront::Distribution Properties: DistributionConfig: Enabled: true Origins: # Static website domain of above bucket - DomainName: !Sub \u0026#34;${S3Bucket}.s3-website-${self:provider.region}.amazonaws.com\u0026#34; Id: S3Origin # Unique ID for this origin in the distribution CustomOriginConfig: HTTPPort: 80 HTTPSPort: 443 OriginProtocolPolicy: http-only DefaultCacheBehavior: TargetOriginId: S3Origin # Link the default behavior to the S3 origin ViewerProtocolPolicy: redirect-to-https # Redirect HTTP requests to HTTPS AllowedMethods: - GET # Allow GET requests - HEAD # Allow HEAD requests CachedMethods: - GET # Cache GET requests - HEAD # Cache HEAD requests ForwardedValues: QueryString: false # Do not forward query strings to the origin (S3) Cookies: Forward: none # Do not forward cookies to the origin (S3) # Serve index.html when accessing the root of the CloudFront domain DefaultRootObject: index.html ViewerCertificate: # Use the default CloudFront certificate (*.cloudfront.net) CloudFrontDefaultCertificate: true # Limit CloudFront to the lowest-cost edge locations (PriceClass_100, PriceClass_200, PriceClass_All) PriceClass: PriceClass_100 HttpVersion: http2 # Use HTTP/2 for better performance Comment: \u0026#34;CloudFront distribution for serving S3 static website\u0026#34; Tất Cả Cấu Hình Trong serverless.yml\nservice: fcj-ws-fe provider: name: aws region: ap-southeast-1 stage: dev resources: Resources: # Define the S3 bucket resource S3Bucket: Type: AWS::S3::Bucket Properties: # Specify the bucket name with a dynamic name based on the service and stage BucketName: ${self:service}-${self:provider.stage} WebsiteConfiguration: # Configure the bucket to serve a static website IndexDocument: index.html # Default page to serve ErrorDocument: index.html # Error page to serve (useful for single-page apps) PublicAccessBlockConfiguration: # Disable public access block BlockPublicAcls: false IgnorePublicAcls: false BlockPublicPolicy: false RestrictPublicBuckets: false # Set the bucket policy to allow public read access S3BucketPolicy: Type: AWS::S3::BucketPolicy Properties: Bucket: !Ref S3Bucket PolicyDocument: Version: \u0026#34;2012-10-17\u0026#34; Statement: - Sid: PublicReadGetObject Effect: Allow Principal: \u0026#34;*\u0026#34; Action: \u0026#34;s3:GetObject\u0026#34; Resource : !Sub \u0026#34;${S3Bucket.Arn}/*\u0026#34; # Define the CloudFront distribution resource CloudFrontDistribution: Type: AWS::CloudFront::Distribution Properties: DistributionConfig: Enabled: true # Enable the CloudFront distribution Origins: - DomainName: !Sub \u0026#34;${S3Bucket}.s3-website-${self:provider.region}.amazonaws.com\u0026#34; # Use the S3 website endpoint Id: S3Origin # Unique ID for this origin in the distribution CustomOriginConfig: HTTPPort: 80 HTTPSPort: 443 OriginProtocolPolicy: http-only DefaultCacheBehavior: TargetOriginId: S3Origin # Link the default behavior to the S3 origin ViewerProtocolPolicy: redirect-to-https # Redirect HTTP requests to HTTPS AllowedMethods: - GET # Allow GET requests - HEAD # Allow HEAD requests CachedMethods: - GET # Cache GET requests - HEAD # Cache HEAD requests ForwardedValues: QueryString: false # Do not forward query strings to the origin (S3) Cookies: Forward: none # Do not forward cookies to the origin (S3) DefaultRootObject: index.html # Serve index.html when accessing the root of the CloudFront domain ViewerCertificate: CloudFrontDefaultCertificate: true # Use the default CloudFront certificate (*.cloudfront.net) PriceClass: PriceClass_100 # Limit CloudFront to the lowest-cost edge locations HttpVersion: http2 # Use HTTP/2 for better performance Comment: \u0026#34;CloudFront distribution for serving S3 static website\u0026#34; # Description of the distribution Outputs: # Output the CloudFront domain name CloudFrontDomain: Value: Fn::GetAtt: [CloudFrontDistribution, DomainName] # Get the domain name of the CloudFront distribution Triển Khai Hạ Tầng\nNhớ thêm tệp .env chứa AWS_ACCESS_KEY_ID và AWS_SECRET_ACCESS_KEY mà chúng ta đã tạo trong bước trước vào thư mục gốc của dự án.\nTriển khai các tài nguyên được định nghĩa trong tệp serverless.yml bằng cách sử dụng CLI của Serverless:\nserverless deploy "
},
{
	"uri": "//localhost:1313/vi/2-tasklist/2.3-createlambdaandinfrastructureforbackend/",
	"title": "Create resource and lambda functions for backend",
	"tags": [],
	"description": "",
	"content": "Introduction Trong bước này, chúng ta sẽ thiết lập DynamoDB, API Gateway, Cognito, và Lambda functions.\nRepository: fcj-ws-api\nCác Bước Thực Hiện Lấy Mã Nguồn Backend\nSource: fcj-ws-api\nCài Đặt Serverless Framework và dependencies\nBạn đã cài đặt ở bước 2.2. Không cần thực hiện lại.\nCấu Trúc Thư Mục Dự Án\nTrong phần này, chúng tôi sẽ mô tả cấu trúc của thư mục dự án và giải thích mục đích của từng thư mục và tệp.\nThư mục dự án fcj-ws-api được tổ chức như sau:\nresources/: Chứa các mẫu CloudFormation và tệp cấu hình để định nghĩa các tài nguyên AWS.\niam/: Định nghĩa các vai trò IAM. lambdaRole.yml: Xác định vai trò IAM và các chính sách cho các hàm Lambda. lambda/: Định nghĩa các hàm Lambda và cấu hình của chúng. cognito.yml: Định nghĩa cấu hình cho AWS Cognito User Pool và các thiết lập liên quan. dynamo.yml: Định nghĩa cấu hình cho các bảng DynamoDB. src/: Chứa mã nguồn cho các hàm Lambda.\nserverless.yml: Tệp cấu hình chính cho Serverless Framework, định nghĩa dịch vụ, nhà cung cấp, các hàm và tài nguyên.\npackage.json: Chứa các phụ thuộc của dự án, các script và metadata.\nProject Config\nservice: fcj-ws-api # Service name custom: base: ${self:service}-${self:provider.stage} dynamo: TodoTable: ${self:service}-todo-${sls:stage} iam: LambdaRole: name: ${self:custom.base}-lambda-role cognito: UserPoolName: ${self:custom.base}-user-pool UserPoolClient: ${self:custom.base}-user-pool-client Domain: ${self:custom.base}-auth build: # Config to use ES6 esbuild: # Enable or Disable bundling the function code and dependencies. (Default: true) bundle: true # Enable minifying function code. (Default: false) minify: false provider: name: aws runtime: nodejs20.x # Define lambda runtime environment region: ap-southeast-1 # Define AWS region stage: dev httpApi: # Config API Gateway v2 cors: # Config CORS allowedOrigins: \u0026#39;*\u0026#39; allowedHeaders: \u0026#39;*\u0026#39; allowedMethods: - GET - POST - PUT - DELETE - OPTIONS maxAge: 6000 # authorizers: # Config Authorization CognitoAuthorizer: type: jwt identitySource: $request.header.Authorization issuerUrl: Fn::Sub: https://cognito-idp.${self:provider.region}.amazonaws.com/${CognitoUserPool} audience: - Ref: CognitoUserPoolClient environment: # Config env variable TODO_TABLE: ${self:custom.dynamo.TodoTable} Cấu Hình lambda role\nTrong phần này, chúng ta định nghĩa IAM roles cho các hàm Lambda. Vai trò này cấp quyền cần thiết cho các hàm Lambda để tương tác với các dịch vụ AWS như DynamoDB.\nDưới đây là định nghĩa tài nguyên cho LambdaRole trong resources:.\nresources: Resources: LambdaRole: Type: AWS::IAM::Role Properties: RoleName: ${self:custom.iam.LambdaRole.name} AssumeRolePolicyDocument: Version: \u0026#34;2012-10-17\u0026#34; Statement: - Effect: Allow Principal: Service: - lambda.amazonaws.com Action: sts:AssumeRole ManagedPolicyArns: - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole Policies: - PolicyName: lambda-permissions PolicyDocument: Version: \u0026#34;2012-10-17\u0026#34; Statement: - Effect: \u0026#34;Allow\u0026#34; Action: - \u0026#34;dynamodb:PutItem\u0026#34; - \u0026#34;dynamodb:Get*\u0026#34; - \u0026#34;dynamodb:Scan*\u0026#34; - \u0026#34;dynamodb:UpdateItem\u0026#34; - \u0026#34;dynamodb:DeleteItem\u0026#34; Resource: - arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:custom.dynamo.TodoTable} DynamoDB Table\nTrong phần này, chúng tôi định nghĩa một tài nguyên bảng DynamoDB tên là TodoTable. Bảng này sẽ được sử dụng để lưu trữ dữ liệu người dùng và sẽ được cấu hình với id làm khóa phân vùng và username làm khóa sắp xếp.\nDưới đây là định nghĩa tài nguyên cho bảng DynamoDB trong resources:.\nresources: Resources: TodoTable: Type: AWS::DynamoDB::Table Properties: TableName: ${self:custom.dynamo.TodoTable} # Get table name from custom defined above AttributeDefinitions: - AttributeName: id AttributeType: S - AttributeName: username AttributeType: S KeySchema: - AttributeName: id # Define partition key KeyType: HASH - AttributeName: username # Define sort key KeyType: RANGE BillingMode: PAY_PER_REQUEST # Define billing mode (on demand) Cognito Configuration\nTrong phần này, chúng tôi sẽ cấu hình Amazon Cognito User Pool và User Pool Client, sẽ xử lý xác thực và quản lý người dùng trong ứng dụng. Cognito giúp quản lý đăng ký người dùng, đăng nhập và kiểm soát truy cập.\nDưới đây là cấu hình cho Cognito:\nresources: Resources: # Cognito User Pool: This creates the Cognito User Pool for handling user authentication. CognitoUserPool: Type: AWS::Cognito::UserPool Properties: # Name of the User Pool (from custom variables). UserPoolName: ${self:custom.cognito.UserPoolName} # Users will log in using their email address. UsernameAttributes: - email # Automatically verify users based on their email. AutoVerifiedAttributes: - email # Define recovery settings (e.g., recovering accounts via verified email). AccountRecoverySetting: RecoveryMechanisms: - Priority: 1 Name: \u0026#34;verified_email\u0026#34; # Define the schema for the User Pool; in this case, we only require an email. Schema: - Name: email Required: true # Cognito User Pool Client: This creates a client that will allow the front-end to authenticate with Cognito. CognitoUserPoolClient: Type: AWS::Cognito::UserPoolClient Properties: # Name of the User Pool Client (from custom variables). ClientName: ${self:custom.cognito.UserPoolClient} # The User Pool this client is associated with. UserPoolId: Ref: CognitoUserPool # Allow only admin authentication flow (no SRP authentication method). ExplicitAuthFlows: - ADMIN_NO_SRP_AUTH # No need to generate a secret key for this client. GenerateSecret: false # Enable OAuth 2.0 implicit flow for authentication. AllowedOAuthFlows: - implicit # Explicitly allow this client to use OAuth flows. AllowedOAuthFlowsUserPoolClient: true # Define the OAuth scopes that are allowed for this client. AllowedOAuthScopes: - email - openid # URL to redirect users to after successful login (from CloudFront distribution output). CallbackURLs: # CloudFrontDomain is got from CloudFormation outputs of Frontend (2.2) # Replace with your app\u0026#39;s callback URL if you update service name in serverless.yml of frontend project - https://${cf:fcj-ws-fe-${self:provider.stage}.CloudFrontDomain}/callback # URL to redirect users to after they log out of the app. LogoutURLs: # CloudFrontDomain is got from CloudFormation outputs of Frontend (2.2) # Replace with your app\u0026#39;s signout URL if you update service name in serverless.yml of frontend project - https://${cf:fcj-ws-fe-${self:provider.stage}.CloudFrontDomain}/login # Enable enhanced error handling to prevent user existence errors during login. PreventUserExistenceErrors: ENABLED # Supported identity provider for this client (in this case, it\u0026#39;s Cognito itself). SupportedIdentityProviders: - COGNITO # Cognito User Pool Domain: Set up a custom domain for the Cognito hosted UI. CognitoUserPoolDomain: Type: AWS::Cognito::UserPoolDomain Properties: # Define a custom domain name for the Cognito hosted UI (from custom variables). Domain: ${self:custom.cognito.Domain} # The User Pool to associate with this domain. UserPoolId: Ref: CognitoUserPool Outputs: # Output the User Pool ID. cognitoUserPoolId: Value: Ref: CognitoUserPool # Output the User Pool Client ID. cognitoUserPoolClientId: Value: Ref: CognitoUserPoolClient # Output the custom domain name for the hosted UI. cognitoUserPoolDomain: Value: Ref: CognitoUserPoolDomain # Output the full URL for the Cognito Hosted UI login page. cognitoHostedUIUrl: Value: # This generates the complete URL for the Cognito Hosted UI login page. # It includes the User Pool Domain, Client ID, OAuth response type, scopes, and the CloudFront callback URL. Fn::Sub: \u0026#34;https://${CognitoUserPoolDomain}.auth.${AWS::Region}.amazoncognito.com/login?client_id=${CognitoUserPoolClient}\u0026amp;response_type=token\u0026amp;scope=email+openid\u0026amp;redirect_uri=https://${cf:fcj-ws-fe-${self:provider.stage}.CloudFrontDomain}/callback\u0026#34; API Configuration\nTrong phần này, chúng ta sẽ giải thích chi tiết cấu hình của một hàm Lambda cụ thể, bao gồm handler, tên hàm, IAM role, và các sự kiện kích hoạt.\n# Code for this lambda function handler: src/createTodo/handler.createTodo # Lambda function name name: ${self:custom.base}-create-todo # Lambda function execution role role: !GetAtt LambdaRole.Arn # Event to trigger function events: - httpApi: # API gateway v2 path: /todos method: post authorizer: # Config authorization to use the cognito authorization which was defined above name: CognitoAuthorizer Để xem các hàm khác, vui lòng xem trong repository.\nKết hợp tất cả cấu hình\nservice: fcj-ws-api custom: base: ${self:service}-${self:provider.stage} dynamo: TodoTable: ${self:service}-todo-${sls:stage} iam: LambdaRole: name: ${self:custom.base}-lambda-role cognito: UserPoolName: ${self:custom.base}-user-pool UserPoolClient: ${self:custom.base}-user-pool-client Domain: ${self:custom.base}-auth build: esbuild: # Enable or Disable bundling the function code and dependencies. (Default: true) bundle: true # Enable minifying function code. (Default: false) minify: false provider: name: aws runtime: nodejs20.x region: ap-southeast-1 stage: dev httpApi: cors: allowedOrigins: \u0026#34;*\u0026#34; allowedHeaders: \u0026#34;*\u0026#34; allowedMethods: - GET - POST - PUT - DELETE - OPTIONS maxAge: 6000 # authorizers: CognitoAuthorizer: type: jwt identitySource: $request.header.Authorization issuerUrl: Fn::Sub: https://cognito-idp.${self:provider.region}.amazonaws.com/${CognitoUserPool} audience: - Ref: CognitoUserPoolClient environment: TODO_TABLE: ${self:custom.dynamo.TodoTable} functions: createTodo: ${file(./resources/lambda/createTodo.yml)} getTodos: ${file(./resources/lambda/getTodos.yml)} getTodo: ${file(./resources/lambda/getTodo.yml)} deleteTodo: ${file(./resources/lambda/deleteTodo.yml)} updateTodo: ${file(./resources/lambda/updateTodo.yml)} resources: - ${file(./resources/iam/lambdaRole.yml):resources} - ${file(./resources/dynamo.yml):resources} - ${file(./resources/cognito.yml):resources} Deploy Hãy nhớ thêm tệp .env chứa AWS_ACCESS_KEY_ID và AWS_SECRET_ACCESS_KEY mà chúng ta đã tạo ở bước trước vào thư mục gốc của dự án.\nTriển khai các tài nguyên đã được định nghĩa trong tệp serverless.yml của bạn bằng cách sử dụng Serverless CLI:\nserverless deploy "
},
{
	"uri": "//localhost:1313/vi/4-cleanup/",
	"title": "Dọn Dẹp Tài Nguyên",
	"tags": [],
	"description": "",
	"content": "Dọn Dẹp Tài Nguyên Để đảm bảo rằng bạn không phát sinh các khoản phí không cần thiết và duy trì một môi trường AWS sạch sẽ và có tổ chức, việc dọn dẹp tài nguyên đã tạo ra trong quá trình này là rất quan trọng. Hãy làm theo các bước sau để xóa các tài nguyên:\n1. Xóa S3 Bucket Đi đến AWS Management Console, điều hướng đến S3, và chọn bucket được sử dụng để lưu trữ frontend của bạn. Để xóa bucket:\nChọn bucket. Vào menu \u0026ldquo;Actions\u0026rdquo; và chọn \u0026ldquo;Empty\u0026rdquo; Xác nhận hành động để xóa tất cả các đối tượng trong bucket. 2. Dọn Dẹp Tài Nguyên Backend Trong terminal, điều hướng đến thư mục chứa dự án backend của bạn. Chạy lệnh sau để xóa các tài nguyên backend:\nserverless remove 3. Dọn Dẹp Tài Nguyên Frontend Trong terminal, điều hướng đến thư mục chứa dự án frontend của bạn. Chạy lệnh sau để xóa các tài nguyên frontend:\nserverless remove Đảm bảo rằng các lệnh này chạy thành công.\n"
},
{
	"uri": "//localhost:1313/vi/2-tasklist/2.4-createcicdpipelineforfe/",
	"title": "Tạo Pipeline CI/CD để Triển Khai Frontend Tự Động",
	"tags": [],
	"description": "",
	"content": "Giới Thiệu Trong bước này, chúng ta sẽ thiết lập một pipeline CI/CD sử dụng AWS CodePipeline, CodeBuild và S3. Điều này sẽ cho phép tự động triển khai ứng dụng frontend mỗi khi có một commit mới trong repository.\nRepository: fcj-ws-fe\nCác Bước Thực Hiện 1. Lấy Mã Nguồn Frontend Nguồn: fcj-ws-fe\n2. Tạo và Cấu Hình Pipeline a. Tạo Pipeline trong AWS CodePipeline Đi đến AWS Management Console\nĐiều hướng đến AWS Management Console. Tìm kiếm và chọn CodePipeline. Tạo Một Pipeline\nNhấp vào Create pipeline. Nhập Tên pipeline. Nhấp Next. Cấu Hình Giai Đoạn Nguồn\nNguồn cung cấp: Chọn GitHub (Version 1). Nhấp Connect to GitHub để xác thực và kết nối tài khoản GitHub của bạn. Sau khi kết nối, chọn Repository và Branch mà bạn muốn sử dụng cho pipeline này. Trong Tùy chọn phát hiện thay đổi, chọn GitHub webhooks để kích hoạt pipeline mỗi khi có thay đổi được đẩy lên branch. Nhấp Next. Thêm Giai Đoạn Xây Dựng\nNhà cung cấp xây dựng: Chọn AWS CodeBuild. Khu vực: Chọn cùng khu vực mà bạn muốn triển khai ứng dụng của bạn. Tên dự án: Nhấp Create Project. Cấu Hình Dự Án CodeBuild\nNhập Tên dự án xây dựng. Trong phần Môi trường, chọn môi trường mặc định. Nhập Tên vai trò CodeBuild. Nếu bạn không có, bạn có thể tạo một vai trò mới với các quyền cần thiết. Cấu hình nâng cao: Thêm biến môi trường: REACT_APP_API_BASE_URL: Đặt giá trị này là URL cơ sở API lấy từ đầu ra CloudFormation của backend của bạn. (truy cập CloudFormation, nhấp vào Stacks, chọn Backend stack fcj-ws-api-dev, mở tab Outputs và lấy giá trị cần thiết) REACT_APP_AUTH_URL: Đặt giá trị này là URL giao diện được lưu trữ của Cognito lấy từ đầu ra CloudFormation của backend của bạn. (truy cập CloudFormation, nhấp vào Stacks, chọn Backend stack fcj-ws-api-dev, mở tab Outputs và lấy giá trị cần thiết) Buildspec: Chọn Use a buildspec file. Điều này sẽ sử dụng file buildspec.yml nằm ở thư mục gốc của mã nguồn frontend của bạn. Nhấp Continue to CodePipeline. Hoàn Thành Cấu Hình Giai Đoạn Xây Dựng\nQuay lại cấu hình CodePipeline và nhấp Next. Thêm Giai Đoạn Triển Khai\nNhà cung cấp triển khai: Chọn Amazon S3. Artifact đầu vào: Chọn BuildArtifact. Tên bucket: Nhập tên của bucket S3 mà bạn đã tạo trong các bước trước (từ bước 2.2). Nhấp Next. Xem Xét và Tạo Pipeline\nXem xét tất cả các cấu hình của bạn và nhấp Create pipeline. 3. Theo Dõi và Xác Minh Pipeline Kiểm Tra Thực Thi Pipeline\nTheo dõi pipeline để đảm bảo nó bắt đầu và chạy đúng cách. Bạn có thể thấy trạng thái của từng giai đoạn trong bảng điều khiển AWS CodePipeline. Xác Minh Triển Khai\nTruy cập vào bucket S3 mà bạn đã chỉ định trong giai đoạn triển khai. Xác minh rằng các artifact xây dựng mới nhất đã được triển khai thành công. Bằng cách thực hiện các bước này, bạn sẽ thiết lập một pipeline CI/CD tự động xây dựng và triển khai ứng dụng frontend React của bạn lên S3 mỗi khi có thay đổi được thực hiện trong repository GitHub.\n"
},
{
	"uri": "//localhost:1313/vi/3-conclusion/",
	"title": "Dọn dẹp tài nguyên  ",
	"tags": [],
	"description": "",
	"content": "Chúng ta sẽ tiến hành các bước sau để xóa các tài nguyên chúng ta đã tạo trong bài thực hành này.\nXóa EC2 instance Truy cập giao diện quản trị dịch vụ EC2 Click Instances. Click chọn cả 2 instance Public Linux Instance và Private Windows Instance. Click Instance state. Click Terminate instance, sau đó click Terminate để xác nhận. Truy cập giao diện quản trị dịch vụ IAM Click Roles. Tại ô tìm kiếm , điền SSM. Click chọn SSM-Role. Click Delete, sau đó điền tên role SSM-Role và click Delete để xóa role. Click Users. Click chọn user Portfwd. Click Delete, sau đó điền tên user Portfwd và click Delete để xóa user. Xóa S3 bucket Truy cập giao diện quản trị dịch vụ System Manager - Session Manager. Click tab Preferences. Click Edit. Kéo chuột xuống dưới. Tại mục S3 logging. Bỏ chọn Enable để tắt tính năng logging. Kéo chuột xuống dưới. Click Save. Truy cập giao diện quản trị dịch vụ S3 Click chọn S3 bucket chúng ta đã tạo cho bài thực hành. ( Ví dụ : lab-fcj-bucket-0001 ) Click Empty. Điền permanently delete, sau đó click Empty để tiến hành xóa object trong bucket. Click Exit. Sau khi xóa hết object trong bucket, click Delete Điền tên S3 bucket, sau đó click Delete bucket để tiến hành xóa S3 bucket. Xóa các VPC Endpoint Truy cập vào giao diện quản trị dịch vụ VPC Click Endpoints. Chọn 4 endpoints chúng ta đã tạo cho bài thực hành bao gồm SSM, SSMMESSAGES, EC2MESSAGES, S3GW. Click Actions. Click Delete VPC endpoints. Tại ô confirm , điền delete. Click Delete để tiến hành xóa các endpoints. Click biểu tượng refresh, kiểm tra tất cả các endpoints đã bị xóa trước khi làm bước tiếp theo. Xóa VPC Truy cập vào giao diện quản trị dịch vụ VPC Click Your VPCs. Click chọn Lab VPC. Click Actions. Click Delete VPC. Tại ô confirm, điền delete để xác nhận, click Delete để thực hiện xóa Lab VPC và các tài nguyên liên quan. "
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]