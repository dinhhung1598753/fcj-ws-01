[
{
	"uri": "//localhost:1313/",
	"title": "Build a serverless application ",
	"tags": [],
	"description": "",
	"content": "Build a serverless application Overall In this workshop, I\u0026rsquo;ll introduce Serverless framework and how to use it to build a serverless application and integrate with some aws services.\nInitialize resource for the frontend: You\u0026rsquo;ll use the Serverless Framework to set up the resource needed to deploy a static web application hosted on S3. Initialize resource for the backend and deploy Lambda functions: Using the Serverless Framework, you\u0026rsquo;ll deploy the backend Lambda functions and configure API Gateway, DynamoDB, and other AWS services. Create a CI/CD pipeline: Set up an automated CodePipeline to build and deploy the frontend application to AWS S3 whenever there are updates in the source code repository. Content Introduction Task list Conclusion Clean up resources "
},
{
	"uri": "//localhost:1313/2-tasklist/2.1-createiamforserverless/",
	"title": "Preparing IAM user for Serverless",
	"tags": [],
	"description": "",
	"content": "Preparing IAM User for Serverless In this step, we will create an IAM user and generate secret access keys for the Serverless Framework to interact with AWS resources.\nSteps to follow: Login to the AWS Management Console\nGo to AWS Management Console and sign in with your credentials.\nGo to IAM Dashboard\nIn the AWS Management Console, search for \u0026ldquo;IAM\u0026rdquo; in the search bar and open the IAM Dashboard.\nClick on Users\nFrom the left-hand side menu, select Users. Here, you\u0026rsquo;ll manage all the users in your AWS account.\nCreate User\nClick on the Add user button. Enter a User name (e.g., serverless-deployer). Select the Access type as \u0026ldquo;Programmatic access\u0026rdquo; to generate the Access key and Secret access key that the Serverless Framework will use. Attach Policies Directly\nIn the \u0026ldquo;Set permissions\u0026rdquo; section, choose Attach policies directly. For more granular control, we\u0026rsquo;ll create a custom policy in the next step. Create Policy\nIn the \u0026ldquo;Attach policies\u0026rdquo; section, click on Create policy. Choose JSON in the Policy Editor\nIn the policy creation wizard, switch to the JSON tab in the policy editor. Add Policy Permissions\nCopy and paste the following JSON into the editor, which grants the necessary permissions to manage needed resources. You can customize this policy based on the services you\u0026rsquo;ll be using.\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;Statement1\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;cloudformation:*\u0026#34;, \u0026#34;lambda:*\u0026#34;, \u0026#34;s3:*\u0026#34;, \u0026#34;logs:*\u0026#34;, \u0026#34;dynamodb:*\u0026#34;, \u0026#34;events:*\u0026#34;, \u0026#34;apigateway:*\u0026#34;, \u0026#34;iam:GetRole\u0026#34;, \u0026#34;iam:CreateRole\u0026#34;, \u0026#34;iam:*\u0026#34;, \u0026#34;cognito-idp:*\u0026#34;, \u0026#34;cloudfront:*\u0026#34; ], \u0026#34;Resource \u0026#34;: \u0026#34;*\u0026#34; } ] } Review and Create Policy\nClick Next: Review. Provide a Name for your policy (e.g., ServerlessDeploymentPolicy) and review the permissions. Click Create policy to finalize. Attach the New Policy\nAfter creating the policy, return to the user creation screen. In the \u0026ldquo;Attach policies\u0026rdquo; section, search for the policy you just created (e.g., ServerlessDeploymentPolicy). Select the policy from the list and click Next. Complete User Creation Review the IAM user’s details and attached permissions. Click Create user to finish creating the user. Download the Access Keys After successfully creating the IAM user, you need to generate and download the access keys:\nClick on the IAM User\nIn the IAM Dashboard, click on the user you just created from the list of users.\nNavigate to the Security Credentials Tab\nGo to the Security credentials tab.\nCreate an Access Key\nScroll down to the Access keys section. Click on the Create access key button. Choose Application Type\nIn the \u0026ldquo;Create access key\u0026rdquo; wizard, select Application running outside AWS. Click Next to proceed. Download the Access Key\nOnce the access key is created, you will see the Access key ID and Secret access key. Download the credentials by clicking the Download .csv button, or manually copy the Access key ID and Secret access key. Important: Make sure to store these credentials securely as you will need them to configure the Serverless Framework. The Secret access key will only be shown once, so be sure to save it immediately.\nYou will use these credentials in the next steps to configure the Serverless Framework.\nConfigure Serverless Framework with IAM User Credentials With Serverless Framework version 4, you no longer need to configure credentials via command line. Instead, you can add them directly to your project’s .env file:\nOpen Your Project Directory\nNavigate to the root directory of your Serverless project.\nCreate or Edit the .env File\nIf you don’t have a .env file already, create one in the root directory of your project. If it exists, open it for editing.\nAdd Your Credentials\nAdd the following lines to the .env file, replacing \u0026lt;Your_Access_Key_ID\u0026gt; and \u0026lt;Your_Secret_Access_Key\u0026gt; with the actual values:\nAWS_ACCESS_KEY_ID=\u0026lt;Your_Access_Key_ID\u0026gt; AWS_SECRET_ACCESS_KEY=\u0026lt;Your_Secret_Access_Key\u0026gt; Save the .env File\nEnsure the file is saved with the correct credentials.\nThe Serverless Framework will automatically use these credentials for deployments and other operations.\n"
},
{
	"uri": "//localhost:1313/1-introduce/",
	"title": "Workshop Overview",
	"tags": [],
	"description": "",
	"content": "Objectives: After this workshop, you will be able to:\nCreate resources using the Serverless Framework Deploy Lambda functions Create a CI/CD pipeline using CodePipeline, CodeBuild, and CodeDeploy Repositories: FE: fcj-ws-fe\nBE: fcj-ws-api\nDuration: This workshop will take 2 hours to complete.\nArchitecture: "
},
{
	"uri": "//localhost:1313/2-tasklist/2.2-createfeinfrastructure/",
	"title": "Create S3 Static Website and CloudFront",
	"tags": [],
	"description": "",
	"content": "Introduction In this step, we will set up an S3 bucket to host a static website and configure a CloudFront distribution to serve the content through a CDN.\nSteps to Follow Pull Frontend Source\nSource: fcj-ws-fe\nInstall serverless framework and dependencies\nnpm i -g serverless@4.2.5 Verify Installation\nserverless --version Install Project Dependencies\nnpm install Create resources: S3 Bucket and CloudFront\nDefine Service name and AWS region\nPlease replace service name with your name you want\nservice: fcj-ws-fe # Your service name provider: name: aws region: ap-southeast-1 # aws region stage: dev Define S3 Bucket and Configuration\nAdd the following configuration to your serverless.yml file to create an S3 bucket and configure it for static website hosting:\n# Define the S3 bucket resource S3Bucket: Type: AWS::S3::Bucket Properties: # The bucket name in this example is \u0026#34;fcj-ws-fe-dev\u0026#34;, you need to change Bucket name or service name to make Bucket name is unique BucketName: ${self:service}-${self:provider.stage} WebsiteConfiguration: # Configure the bucket to serve a static website IndexDocument: index.html # Default page to serve ErrorDocument: index.html # Error page to serve (useful for single-page apps) PublicAccessBlockConfiguration: # Disable public access block for bucket policy BlockPublicAcls: true IgnorePublicAcls: true BlockPublicPolicy: false RestrictPublicBuckets: false Set the Bucket Policy for Public Read Access\nAdd the following configuration to allow public read access to the S3 bucket:\n# Set the bucket policy to allow public read access S3BucketPolicy: Type: AWS::S3::BucketPolicy Properties: Bucket: !Ref S3Bucket PolicyDocument: Version: \u0026#34;2012-10-17\u0026#34; Statement: - Sid: PublicReadGetObject Effect: Allow Principal: \u0026#34;*\u0026#34; Action: \u0026#34;s3:GetObject\u0026#34; Resource: !Sub \u0026#34;${S3Bucket.Arn}/*\u0026#34; Create CloudFront Distribution\nAdd the following configuration to create a CloudFront distribution:\n# Define the CloudFront distribution resource CloudFrontDistribution: Type: AWS::CloudFront::Distribution Properties: DistributionConfig: Enabled: true Origins: # Static website domain of above bucket - DomainName: !Sub \u0026#34;${S3Bucket}.s3-website-${self:provider.region}.amazonaws.com\u0026#34; Id: S3Origin # Unique ID for this origin in the distribution CustomOriginConfig: HTTPPort: 80 HTTPSPort: 443 OriginProtocolPolicy: http-only DefaultCacheBehavior: TargetOriginId: S3Origin # Link the default behavior to the S3 origin ViewerProtocolPolicy: redirect-to-https # Redirect HTTP requests to HTTPS AllowedMethods: - GET # Allow GET requests - HEAD # Allow HEAD requests CachedMethods: - GET # Cache GET requests - HEAD # Cache HEAD requests ForwardedValues: QueryString: false # Do not forward query strings to the origin (S3) Cookies: Forward: none # Do not forward cookies to the origin (S3) # Serve index.html when accessing the root of the CloudFront domain DefaultRootObject: index.html ViewerCertificate: # Use the default CloudFront certificate (*.cloudfront.net) CloudFrontDefaultCertificate: true # Limit CloudFront to the lowest-cost edge locations (PriceClass_100, PriceClass_200, PriceClass_All) PriceClass: PriceClass_100 HttpVersion: http2 # Use HTTP/2 for better performance Comment: \u0026#34;CloudFront distribution for serving S3 static website\u0026#34; All configuration in serverless.yml\nservice: fcj-ws-fe provider: name: aws region: ap-southeast-1 stage: dev resources: Resources: # Define the S3 bucket resource S3Bucket: Type: AWS::S3::Bucket Properties: # Specify the bucket name with a dynamic name based on the service and stage BucketName: ${self:service}-${self:provider.stage} WebsiteConfiguration: # Configure the bucket to serve a static website IndexDocument: index.html # Default page to serve ErrorDocument: index.html # Error page to serve (useful for single-page apps) PublicAccessBlockConfiguration: # Disable public access block BlockPublicAcls: false IgnorePublicAcls: false BlockPublicPolicy: false RestrictPublicBuckets: false # Set the bucket policy to allow public read access S3BucketPolicy: Type: AWS::S3::BucketPolicy Properties: Bucket: !Ref S3Bucket PolicyDocument: Version: \u0026#34;2012-10-17\u0026#34; Statement: - Sid: PublicReadGetObject Effect: Allow Principal: \u0026#34;*\u0026#34; Action: \u0026#34;s3:GetObject\u0026#34; Resource: !Sub \u0026#34;${S3Bucket.Arn}/*\u0026#34; # Define the CloudFront distribution resource CloudFrontDistribution: Type: AWS::CloudFront::Distribution Properties: DistributionConfig: Enabled: true # Enable the CloudFront distribution Origins: - DomainName: !Sub \u0026#34;${S3Bucket}.s3-website-${self:provider.region}.amazonaws.com\u0026#34; # Use the S3 website endpoint Id: S3Origin # Unique ID for this origin in the distribution CustomOriginConfig: HTTPPort: 80 HTTPSPort: 443 OriginProtocolPolicy: http-only DefaultCacheBehavior: TargetOriginId: S3Origin # Link the default behavior to the S3 origin ViewerProtocolPolicy: redirect-to-https # Redirect HTTP requests to HTTPS AllowedMethods: - GET # Allow GET requests - HEAD # Allow HEAD requests CachedMethods: - GET # Cache GET requests - HEAD # Cache HEAD requests ForwardedValues: QueryString: false # Do not forward query strings to the origin (S3) Cookies: Forward: none # Do not forward cookies to the origin (S3) DefaultRootObject: index.html # Serve index.html when accessing the root of the CloudFront domain ViewerCertificate: CloudFrontDefaultCertificate: true # Use the default CloudFront certificate (*.cloudfront.net) PriceClass: PriceClass_100 # Limit CloudFront to the lowest-cost edge locations HttpVersion: http2 # Use HTTP/2 for better performance Comment: \u0026#34;CloudFront distribution for serving S3 static website\u0026#34; # Description of the distribution Outputs: # Output the CloudFront domain name CloudFrontDomain: Value: Fn::GetAtt: [CloudFrontDistribution, DomainName] # Get the domain name of the CloudFront distribution Deploy\nRemember add the .env AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY we create in previous step with file to root level of the project\nDeploy the resources defined in your serverless.yml file using the Serverless CLI:\nserverless deploy "
},
{
	"uri": "//localhost:1313/2-tasklist/",
	"title": "Task List",
	"tags": [],
	"description": "",
	"content": "List task will be performed: Create IAM user for Serverless Framework Create S3 static web and CloudFront Create infrastructure for backend (Lambda, API Gateway, Cognito, DynamoDB) Create CI/CD pipeline for Frontend "
},
{
	"uri": "//localhost:1313/3-conclusion/",
	"title": "Conclusion",
	"tags": [],
	"description": "",
	"content": "Conclusion In this project, we have successfully implemented a comprehensive serverless architecture to support a modern web application. The steps we followed include setting up the frontend and backend components, and integrating them through a CI/CD pipeline to automate deployments.\nKey Achievements Frontend Deployment:\nWe configured an AWS S3 bucket to host a static website, with CloudFront as the CDN to deliver content efficiently and securely. The static site is automatically updated using a CI/CD pipeline whenever changes are pushed to the GitHub repository. Backend resources:\nWe set up a robust backend using AWS services including DynamoDB for data storage, AWS Cognito for user management, and Lambda functions to handle API requests. The backend is securely integrated with API Gateway to expose endpoints and manage authentication via Cognito. CI/CD Pipeline:\nWe created a CI/CD pipeline using AWS CodePipeline and CodeBuild to automate the build and deployment process for the frontend application. The pipeline ensures that updates to the GitHub repository trigger automated builds and deployments to the S3 bucket, maintaining a smooth and consistent delivery process. Lessons Learned Serverless Architecture: Implementing a serverless architecture allows for scalable and cost-efficient solutions, reducing the need for server management and enabling developers to focus on application logic.\nCI/CD Integration: Automating deployments with CI/CD pipelines enhances development efficiency and reduces the risk of manual errors, ensuring that the latest features and fixes are promptly delivered.\nAWS Service Integration: Leveraging various AWS services like S3, CloudFront, Lambda, API Gateway, and CodePipeline demonstrates how to build and deploy scalable, secure, and efficient applications using cloud technologies.\nBy following the outlined steps and integrating these services, we have built a foundation for a scalable web application that can evolve and grow with future requirements. This project exemplifies the power of serverless architecture and modern cloud practices in creating robust and efficient applications.\n"
},
{
	"uri": "//localhost:1313/2-tasklist/2.3-createlambdaandinfrastructureforbackend/",
	"title": "Create resource and lambda functions for backend",
	"tags": [],
	"description": "",
	"content": "Introduction In this step, we will set up DynamoDB, API Gateway, Cognito, and Lambda functions.\nRepository: fcj-ws-api\nSteps to Follow Pull Backend Source\nSource: fcj-ws-api\nInstall serverless framework and dependencies\nYou have installed in step 2.2. No need to perform again.\nProject Directory Structure\nIn this section, we\u0026rsquo;ll outline the structure of the project directory and explain the purpose of each folder and file.\nThe project directory fcj-ws-api is organized as follows:\nresources/: Contains CloudFormation templates and configuration files for defining AWS resources.\niam/: Defines IAM roles. lambdaRole.yml: Specifies the IAM role and policies for Lambda functions. lambda/: Defines Lambda functions and their configurations. cognito.yml: Defines the configuration for AWS Cognito User Pool and related settings. dynamo.yml: Defines the configuration for DynamoDB tables. src/: Contains the source code for Lambda functions.\nserverless.yml: The main configuration file for the Serverless Framework, defining the service, provider, functions, and resources.\npackage.json: Contains the project\u0026rsquo;s dependencies, scripts, and metadata.\nProject Config\nservice: fcj-ws-api # Service name custom: base: ${self:service}-${self:provider.stage} dynamo: TodoTable: ${self:service}-todo-${sls:stage} iam: LambdaRole: name: ${self:custom.base}-lambda-role cognito: UserPoolName: ${self:custom.base}-user-pool UserPoolClient: ${self:custom.base}-user-pool-client Domain: ${self:custom.base}-auth build: # Config to use ES6 esbuild: # Enable or Disable bundling the function code and dependencies. (Default: true) bundle: true # Enable minifying function code. (Default: false) minify: false provider: name: aws runtime: nodejs20.x # Define lambda runtime environment region: ap-southeast-1 # Define AWS region stage: dev httpApi: # Config API Gateway v2 cors: # Config CORS allowedOrigins: \u0026#39;*\u0026#39; allowedHeaders: \u0026#39;*\u0026#39; allowedMethods: - GET - POST - PUT - DELETE - OPTIONS maxAge: 6000 # authorizers: # Config Authorization CognitoAuthorizer: type: jwt identitySource: $request.header.Authorization issuerUrl: Fn::Sub: https://cognito-idp.${self:provider.region}.amazonaws.com/${CognitoUserPool} audience: - Ref: CognitoUserPoolClient environment: # Config env variable TODO_TABLE: ${self:custom.dynamo.TodoTable} Config lambda role\nIn this section, we define the IAM Role for Lambda functions. This role gives the Lambda functions the necessary permissions to interact with AWS services like DynamoDB.\nThe following is the resource definition for the LambdaRole in resources:.\nresources: Resources: LambdaRole: Type: AWS::IAM::Role Properties: RoleName: ${self:custom.iam.LambdaRole.name} AssumeRolePolicyDocument: Version: \u0026#34;2012-10-17\u0026#34; Statement: - Effect: Allow Principal: Service: - lambda.amazonaws.com Action: sts:AssumeRole ManagedPolicyArns: - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole Policies: - PolicyName: lambda-permissions PolicyDocument: Version: \u0026#34;2012-10-17\u0026#34; Statement: - Effect: \u0026#34;Allow\u0026#34; Action: - \u0026#34;dynamodb:PutItem\u0026#34; - \u0026#34;dynamodb:Get*\u0026#34; - \u0026#34;dynamodb:Scan*\u0026#34; - \u0026#34;dynamodb:UpdateItem\u0026#34; - \u0026#34;dynamodb:DeleteItem\u0026#34; Resource: - arn:aws:dynamodb:${aws:region}:${aws:accountId}:table/${self:custom.dynamo.TodoTable} DynamoDB Table\nIn this section, we define a DynamoDB table resource named TodoTable. This table will be used to store user data and will be configured with id as the partition key and username as the sort key.\nThe following is the resource definition for the DynamoDB table in resources:.\nresources: Resources: TodoTable: Type: AWS::DynamoDB::Table Properties: TableName: ${self:custom.dynamo.TodoTable} # Get table name from custom defined above AttributeDefinitions: - AttributeName: id AttributeType: S - AttributeName: username AttributeType: S KeySchema: - AttributeName: id # Define partition key KeyType: HASH - AttributeName: username # Define sort key KeyType: RANGE BillingMode: PAY_PER_REQUEST # Define billing mode (on demand) Cognito Configuration\nIn this section, we will configure an Amazon Cognito User Pool and User Pool Client, which will handle authentication and user management in the application. Cognito helps manage user sign-up, sign-in, and access control.\nThe following is the configuration for Cognito:\nresources: Resources: # Cognito User Pool: This creates the Cognito User Pool for handling user authentication. CognitoUserPool: Type: AWS::Cognito::UserPool Properties: # Name of the User Pool (from custom variables). UserPoolName: ${self:custom.cognito.UserPoolName} # Users will log in using their email address. UsernameAttributes: - email # Automatically verify users based on their email. AutoVerifiedAttributes: - email # Define recovery settings (e.g., recovering accounts via verified email). AccountRecoverySetting: RecoveryMechanisms: - Priority: 1 Name: \u0026#34;verified_email\u0026#34; # Define the schema for the User Pool; in this case, we only require an email. Schema: - Name: email Required: true # Cognito User Pool Client: This creates a client that will allow the front-end to authenticate with Cognito. CognitoUserPoolClient: Type: AWS::Cognito::UserPoolClient Properties: # Name of the User Pool Client (from custom variables). ClientName: ${self:custom.cognito.UserPoolClient} # The User Pool this client is associated with. UserPoolId: Ref: CognitoUserPool # Allow only admin authentication flow (no SRP authentication method). ExplicitAuthFlows: - ADMIN_NO_SRP_AUTH # No need to generate a secret key for this client. GenerateSecret: false # Enable OAuth 2.0 implicit flow for authentication. AllowedOAuthFlows: - implicit # Explicitly allow this client to use OAuth flows. AllowedOAuthFlowsUserPoolClient: true # Define the OAuth scopes that are allowed for this client. AllowedOAuthScopes: - email - openid # URL to redirect users to after successful login (from CloudFront distribution output). CallbackURLs: # CloudFrontDomain is got from CloudFormation outputs of Frontend (2.2) # Replace with your app\u0026#39;s callback URL if you update service name in serverless.yml of frontend project - https://${cf:fcj-ws-fe-${self:provider.stage}.CloudFrontDomain}/callback # URL to redirect users to after they log out of the app. LogoutURLs: # CloudFrontDomain is got from CloudFormation outputs of Frontend (2.2) # Replace with your app\u0026#39;s signout URL if you update service name in serverless.yml of frontend project - https://${cf:fcj-ws-fe-${self:provider.stage}.CloudFrontDomain}/login # Enable enhanced error handling to prevent user existence errors during login. PreventUserExistenceErrors: ENABLED # Supported identity provider for this client (in this case, it\u0026#39;s Cognito itself). SupportedIdentityProviders: - COGNITO # Cognito User Pool Domain: Set up a custom domain for the Cognito hosted UI. CognitoUserPoolDomain: Type: AWS::Cognito::UserPoolDomain Properties: # Define a custom domain name for the Cognito hosted UI (from custom variables). Domain: ${self:custom.cognito.Domain} # The User Pool to associate with this domain. UserPoolId: Ref: CognitoUserPool Outputs: # Output the User Pool ID. cognitoUserPoolId: Value: Ref: CognitoUserPool # Output the User Pool Client ID. cognitoUserPoolClientId: Value: Ref: CognitoUserPoolClient # Output the custom domain name for the hosted UI. cognitoUserPoolDomain: Value: Ref: CognitoUserPoolDomain # Output the full URL for the Cognito Hosted UI login page. cognitoHostedUIUrl: Value: # This generates the complete URL for the Cognito Hosted UI login page. # It includes the User Pool Domain, Client ID, OAuth response type, scopes, and the CloudFront callback URL. Fn::Sub: \u0026#34;https://${CognitoUserPoolDomain}.auth.${AWS::Region}.amazoncognito.com/login?client_id=${CognitoUserPoolClient}\u0026amp;response_type=token\u0026amp;scope=email+openid\u0026amp;redirect_uri=https://${cf:fcj-ws-fe-${self:provider.stage}.CloudFrontDomain}/callback\u0026#34; API Configuration\nIn this section, we will explain the detailed configuration of a specific Lambda function, including the handler, function name, IAM role, and event triggers.\n# Code for this lambda function handler: src/createTodo/handler.createTodo # Lambda function name name: ${self:custom.base}-create-todo # Lambda function execution role role: !GetAtt LambdaRole.Arn # Event to trigger function events: - httpApi: # API gateway v2 path: /todos method: post authorizer: # Config authorization to use the cognito authorization which was defined above name: CognitoAuthorizer For other functions, please look into repository.\nCombine all config\nservice: fcj-ws-api custom: base: ${self:service}-${self:provider.stage} dynamo: TodoTable: ${self:service}-todo-${sls:stage} iam: LambdaRole: name: ${self:custom.base}-lambda-role cognito: UserPoolName: ${self:custom.base}-user-pool UserPoolClient: ${self:custom.base}-user-pool-client Domain: ${self:custom.base}-auth build: esbuild: # Enable or Disable bundling the function code and dependencies. (Default: true) bundle: true # Enable minifying function code. (Default: false) minify: false provider: name: aws runtime: nodejs20.x region: ap-southeast-1 stage: dev httpApi: cors: allowedOrigins: \u0026#34;*\u0026#34; allowedHeaders: \u0026#34;*\u0026#34; allowedMethods: - GET - POST - PUT - DELETE - OPTIONS maxAge: 6000 # authorizers: CognitoAuthorizer: type: jwt identitySource: $request.header.Authorization issuerUrl: Fn::Sub: https://cognito-idp.${self:provider.region}.amazonaws.com/${CognitoUserPool} audience: - Ref: CognitoUserPoolClient environment: TODO_TABLE: ${self:custom.dynamo.TodoTable} functions: createTodo: ${file(./resources/lambda/createTodo.yml)} getTodos: ${file(./resources/lambda/getTodos.yml)} getTodo: ${file(./resources/lambda/getTodo.yml)} deleteTodo: ${file(./resources/lambda/deleteTodo.yml)} updateTodo: ${file(./resources/lambda/updateTodo.yml)} resources: - ${file(./resources/iam/lambdaRole.yml):resources} - ${file(./resources/dynamo.yml):resources} - ${file(./resources/cognito.yml):resources} Deploy Remember add the .env AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY we create in previous step with file to root level of the project\nDeploy the resources defined in your serverless.yml file using the Serverless CLI:\nserverless deploy "
},
{
	"uri": "//localhost:1313/4-cleanup/",
	"title": "Clean Up  resources",
	"tags": [],
	"description": "",
	"content": "Clean Up resources To ensure that you do not incur unnecessary charges and to maintain a clean and organized AWS environment, it\u0026rsquo;s important to properly clean up the resources created during this exercise. Follow these steps to delete the resources:\n1. Empty S3 Bucket Go to the AWS Management Console, navigate to S3, and select the bucket used for hosting your frontend. To empty the bucket:\nSelect the bucket. Choose \u0026ldquo;Empty\u0026rdquo; Confirm the action to delete all objects within the bucket. 2. Clean Up Backend resources In your terminal, navigate to the directory containing your backend project. Run the following command to remove the backend resources:\nserverless remove 3. Clean Up Frontend resources In your terminal, navigate to the directory containing your frontend project. Run the following command to remove the frontend resources:\nserverless remove Make sure these commands run successfully.\n"
},
{
	"uri": "//localhost:1313/2-tasklist/2.4-createcicdpipelineforfe/",
	"title": "Create CI/CD Pipeline to Automatically Deploy Frontend",
	"tags": [],
	"description": "",
	"content": "Introduction In this step, we will set up a CI/CD pipeline using AWS CodePipeline, CodeBuild, and S3. This will enable automatic deployment of the frontend application whenever there is a new commit in the repository.\nRepository: fcj-ws-fe\nSteps to Follow 1. Pull Frontend Source Source: fcj-ws-fe\n2. Create and Configure the Pipeline a. Create Pipeline in AWS CodePipeline Go to AWS Management Console\nNavigate to the AWS Management Console. Search for and select CodePipeline. Create a Pipeline\nClick on Create pipeline. Enter a Pipeline name. Click Next. Configure Source Stage\nSource provider: Select GitHub (Version 1). Click Connect to GitHub to authenticate and connect your GitHub account. Once connected, select the Repository and Branch that you want to use for this pipeline. In Change detection options, choose GitHub webhooks to trigger the pipeline whenever changes are pushed to the branch. Click Next. Add Build Stage\nBuild provider: Select AWS CodeBuild. Region: Choose the same region where you want to deploy your application. Project name: Click Create Project. Configure CodeBuild Project\nEnter a Build project name. In the Environment section, select the default environment. Enter the CodeBuild role name. If you don\u0026rsquo;t have one, you can create a new role with the necessary permissions. Advanced configuration: Add environment variables: REACT_APP_API_BASE_URL: Set this to the API base URL obtained from your backend CloudFormation output. (go to CloudFormation, click Stacks, choose Backend stack fcj-ws-api-dev, open Outputs tab and get the needed value) REACT_APP_AUTH_URL: Set this to the Cognito hosted UI URL obtained from your backend CloudFormation output. (go to CloudFormation, click Stacks, choose Backend stack fcj-ws-api-dev, open Outputs tab and get the needed value) Buildspec: Choose Use a buildspec file. This will use the buildspec.yml file located in the root of your frontend source directory. Click Continue to CodePipeline. Complete Build Stage Configuration\nGo back to the CodePipeline configuration and click Next. Add Deploy Stage\nDeploy provider: Select Amazon S3. Input artifact: Choose BuildArtifact. Bucket name: Enter the name of the S3 bucket you created in the previous steps (from step 2.2). Click Next. Review and Create Pipeline\nReview all your configurations and click Create pipeline. 3. Monitor and Verify Pipeline Check Pipeline Execution\nMonitor the pipeline to ensure it starts and runs correctly. You can see the status of each stage in the AWS CodePipeline console. Verify Deployment\nGo to the S3 bucket you specified in the deploy stage. Verify that the latest build artifacts have been deployed successfully. By following these steps, you will set up a CI/CD pipeline that automatically builds and deploys your React frontend application to S3 whenever changes are made to the GitHub repository.\n"
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]